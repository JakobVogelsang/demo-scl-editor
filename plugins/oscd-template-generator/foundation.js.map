{"version":3,"file":"foundation.js","sourceRoot":"","sources":["../foundation.ts"],"names":[],"mappings":"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","sourcesContent":["import { TreeSelection } from '@openenergytools/tree-grid';\n\nexport interface NodeData {\n  name?: string;\n  tagName?: string;\n  typeKind?: string;\n  children?: Record<string, NodeData>;\n  [key: string]: unknown;\n}\n\n/**\n * Get enum values for a given selection and node\n * Returns the enum values that should be added to the selection\n */\nfunction getEnumValues(node: NodeData): Record<string, TreeSelection> {\n  const enumValues: Record<string, TreeSelection> = {};\n\n  if (node.typeKind === 'ENUMERATED' && node.children) {\n    Object.values(node.children).forEach((value: NodeData) => {\n      if (value.name) {\n        enumValues[value.name] = {};\n      }\n    });\n  }\n\n  return enumValues;\n}\n\n/**\n * Adds missing enum values from the node to the selection and returns the updated selection\n */\nfunction selectEnumValues(sel: TreeSelection, node: NodeData): TreeSelection {\n  const enumValues = getEnumValues(node);\n  const newSel: TreeSelection = { ...sel };\n\n  for (const [key, value] of Object.entries(enumValues)) {\n    if (!newSel[key]) {\n      newSel[key] = value;\n    }\n  }\n\n  return newSel;\n}\n\n/**\n * Returns selection of mandatory enumerated nodes if they don't exist.\n */\nfunction selectEnumNode(\n  selection: TreeSelection,\n  node: NodeData\n): TreeSelection {\n  if (!node.children) return selection;\n\n  const newSel: TreeSelection = { ...selection };\n\n  for (const [key, childNode] of Object.entries(node.children)) {\n    if (\n      childNode.typeKind === 'ENUMERATED' &&\n      childNode.mandatory &&\n      !newSel[key]\n    ) {\n      newSel[key] = {};\n    }\n  }\n\n  return newSel;\n}\n\n/**\n * Get the selection object by navigating through a specific path in the tree selection structure\n */\nexport function getSelectionByPath(\n  selection: TreeSelection,\n  path: string[]\n): TreeSelection {\n  let currentSelection = selection;\n\n  for (const segment of path) {\n    currentSelection = currentSelection[segment] || {};\n  }\n\n  return currentSelection;\n}\n\n/**\n * Returns selection of mandatory enums and fills them with values recursively.\n */\nexport function processEnums(\n  selection: TreeSelection,\n  node: NodeData\n): TreeSelection {\n  let newSel: TreeSelection = selectEnumNode(selection, node);\n\n  if (node.typeKind === 'ENUMERATED') {\n    newSel = selectEnumValues(newSel, node);\n  }\n\n  if (node.children) {\n    for (const [key, childSelection] of Object.entries(newSel)) {\n      const childNode = node.children[key];\n      if (childNode) {\n        newSel[key] = processEnums(childSelection as TreeSelection, childNode);\n      }\n    }\n  }\n\n  return newSel;\n}\n\nfunction formatXml(xml: string): string {\n  let formatted = '';\n  let indent = '';\n  const tab = '\\t';\n  xml.split(/>\\s*</).forEach(node => {\n    if (node.match(/^\\/\\w/)) indent = indent.substring(tab.length);\n    formatted += `${indent}<${node}>\\r\\n`;\n    if (node.match(/^<?\\w[^>]*[^/]$/)) indent += tab;\n  });\n  return formatted.substring(1, formatted.length - 3);\n}\n\nexport function serializeAndFormat(doc: XMLDocument): string {\n  const serializer = new XMLSerializer();\n  const xmlString = serializer.serializeToString(doc);\n  return formatXml(xmlString);\n}\n\nexport function createBaseSCLDoc(): XMLDocument {\n  return new DOMParser().parseFromString(\n    `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n      <SCL xmlns=\"http://www.iec.ch/61850/2003/SCL\" version=\"2007\" revision=\"B\" release=\"5\">\n        <Header id=\"LNodeTypePreview\"/>\n      </SCL>`,\n    'application/xml'\n  );\n}\n"]}